// helper: get user session or attempt background anonymous sign-in (non-blocking)
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import toast from 'react-hot-toast';
import { AlertTriangle, CheckCircle, Loader2, Save, Flag, LayoutGrid, Sun, Moon, Calculator as CalcIcon, Star, Eye, AlertCircle, X } from 'lucide-react';
import { supabase } from '../lib/supabase';
import { ViolationModal } from '../components/ViolationModal';
import { Logo } from '../components/Logo';
import { useTranslation } from 'react-i18next';
import { LanguageSwitcher } from '../components/LanguageSwitcher';
import { Calculator } from '../components/Calculator';

interface Question {
    id: string;
    type: string;
    question_text: string;
    options?: string[];
    points: number;
    correct_answer?: string | string[] | null;
    media_url?: string | null;
    media_type?: 'image' | 'audio' | 'video' | null;
}

interface Violation {
    type: string;
    timestamp: string;
}

interface Exam {
    id: string;
    title: string;
    description: string;
    questions: Question[];
    required_fields?: string[];
    settings: {
        require_fullscreen: boolean;
        detect_tab_switch: boolean;
        disable_copy_paste: boolean;
        disable_right_click: boolean;
        max_violations: number;
        time_limit_minutes: number | null;
        randomize_questions?: boolean;
        show_results_immediately?: boolean;
        show_detailed_results?: boolean; // NEW
        // optional scheduling fields (back-end and editor may use either naming)
        start_time?: string | null;
        end_time?: string | null;
        start_date?: string | null;
        end_date?: string | null;
        // email whitelist
        restrict_by_email?: boolean;
        allowed_emails?: string[];
    };
}

export default function ExamView() {
    const { t } = useTranslation();
    const { id } = useParams();
    const navigate = useNavigate();
    const [searchParams] = useSearchParams();
    const submissionId = searchParams.get('submission');
    const isReviewMode = !!submissionId;
    const [exam, setExam] = useState<Exam | null>(null);
    const [studentData, setStudentData] = useState<Record<string, string>>({});
    const [started, setStarted] = useState(false);
    const [answers, setAnswers] = useState<Record<string, any>>({});
    const [violations, setViolations] = useState<Violation[]>([]);
    const [timeLeft, setTimeLeft] = useState<number | null>(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [submitted, setSubmitted] = useState(false);
    const [score, setScore] = useState<{ score: number; max_score: number; percentage: number; submission_id?: string } | null>(null);

    const [showViolationModal, setShowViolationModal] = useState(false);
    const [violationMessage, setViolationMessage] = useState({ title: '', message: '' });
    const [hasPreviousSession, setHasPreviousSession] = useState(false);
    const [isAvailable, setIsAvailable] = useState(true);
    const [availabilityMessage, setAvailabilityMessage] = useState<string | null>(null);
    const [flaggedQuestions, setFlaggedQuestions] = useState<Set<string>>(new Set());

    const [showQuestionGrid, setShowQuestionGrid] = useState(false);
    const [fontSize, setFontSize] = useState<'normal' | 'large' | 'xlarge'>('normal');
    const [highContrast, setHighContrast] = useState(false);
    const [showCalculator, setShowCalculator] = useState(false);
    const [startedAt, setStartedAt] = useState<number | null>(null);

    // New State for View Modes
    const [viewMode, setViewMode] = useState<'list' | 'single'>('single'); // Default to single question per page
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [isZenMode, setIsZenMode] = useState(false);

    // Review Mode State
    const [reviewData, setReviewData] = useState<{
        submission: any;
        submissionAnswers: any[];
    } | null>(null);

    // NEW: State for unanswered questions warning
    const [showUnansweredModal, setShowUnansweredModal] = useState(false);
    const [unansweredQuestions, setUnansweredQuestions] = useState<number[]>([]);
    
    // NEW: State for auto-submit warning
    const [showAutoSubmitWarning, setShowAutoSubmitWarning] = useState(false);
    const [autoSubmitCountdown, setAutoSubmitCountdown] = useState(5);

    const containerRef = useRef<HTMLDivElement>(null);
    const isSubmittingRef = useRef(false);

    // Load exam data or review data
    useEffect(() => {
        if (id) {
            fetchExam();
            if (isReviewMode && submissionId) {
                fetchReviewData(submissionId);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [id, isReviewMode, submissionId]);

    // Check for existing session and submitted status on mount
    useEffect(() => {
        if (!id) return;

        // Check if already submitted on this device
        const submittedFlag = localStorage.getItem(`durrah_exam_${id}_submitted`);
        if (submittedFlag) {
            setSubmitted(true);
            // Optionally try to load the score if we saved it
            const savedScore = localStorage.getItem(`durrah_exam_${id}_score`);
            if (savedScore) {
                const parsed = JSON.parse(savedScore);
                setScore(parsed);

            }
            return;
        }

        // Check for active session to restore
        const savedState = localStorage.getItem(`durrah_exam_${id}_state`);
        if (savedState) {
            try {
                const parsed = JSON.parse(savedState);
                setStudentData(parsed.studentData || {});
                setAnswers(parsed.answers || {});
                setViolations(parsed.violations || []);
                if (parsed.flaggedQuestions) {
                    setFlaggedQuestions(new Set(parsed.flaggedQuestions));
                }
                setStarted(parsed.started || false);
                if (parsed.timeLeft !== null && parsed.timeLeft !== undefined) {
                    setTimeLeft(parsed.timeLeft);
                }
                setHasPreviousSession(true);
                setHasPreviousSession(true);
                toast.success(t('examView.previousSession'));
            } catch (e) {
                console.error('Failed to restore session', e);
            }
        }
    }, [id]);

    // Save state to localStorage whenever it changes
    useEffect(() => {
        if (!id || submitted) return;

        // Only save if we have started or have entered some data
        if (started || Object.keys(studentData).length > 0) {
            const stateToSave = {
                studentData,
                answers,
                violations,
                flaggedQuestions: Array.from(flaggedQuestions),
                timeLeft,
                started,
                startedAt,
                lastUpdated: Date.now()
            };
            localStorage.setItem(`durrah_exam_${id}_state`, JSON.stringify(stateToSave));
        }
    }, [id, studentData, answers, violations, timeLeft, started, startedAt, submitted, flaggedQuestions]);

    const fetchExam = async () => {
        try {
            // Securely fetch exam data (exclude correct_answer for security)
            const { data: examData, error } = await supabase.from('exams').select('*').eq('id', id).single();
            if (error) throw error;

            // Fetch questions WITHOUT correct_answer column
            const { data: qData, error: qError } = await supabase
                .from('questions')
                .select('id, type, question_text, options, points, randomize_options, exam_id, created_at, media_url, media_type')
                .eq('exam_id', id);

            if (qError) throw qError;

            const settings = examData.settings || {};
            const normalizedSettings: any = { ...settings };
            // support both naming conventions
            if (!normalizedSettings.start_time && settings.start_date) normalizedSettings.start_time = settings.start_date;
            if (!normalizedSettings.end_time && settings.end_date) normalizedSettings.end_time = settings.end_date;

            setExam({ ...examData, questions: qData || [], settings: normalizedSettings });

            // Apply Randomization if enabled
            let processedQuestions = [...(qData || [])];

            // 1. Randomize Questions Order
            if (normalizedSettings.randomize_questions) {
                for (let i = processedQuestions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [processedQuestions[i], processedQuestions[j]] = [processedQuestions[j], processedQuestions[i]];
                }
            }

            // 2. Randomize Options Order for each question
            if (normalizedSettings.randomize_options) {
                processedQuestions = processedQuestions.map(q => {
                    const randomizedOptions = q.options ? [...q.options] : [];
                    for (let i = randomizedOptions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [randomizedOptions[i], randomizedOptions[j]] = [randomizedOptions[j], randomizedOptions[i]];
                    }
                    return { ...q, options: randomizedOptions };
                });
            }

            setExam(prev => prev ? { ...prev, questions: processedQuestions } : prev);
        } catch (error) {
            toast.error(t('examView.loadError'));
            console.error('Error fetching exam:', error);
        }
    };

    const fetchReviewData = async (submissionId: string) => {
        try {
            const { data, error } = await supabase
                .from('submissions')
                .select('*, answers:submission_answers(*)')
                .eq('id', submissionId)
                .single();

            if (error) throw error;

            setReviewData(data);
        } catch (error) {
            toast.error(t('examView.loadError'));
            console.error('Error fetching review data:', error);
        }
    };

    const handleStart = () => {
        if (exam) {
            setStarted(true);
            setStartedAt(Date.now());

            // Navigate to first question immediately
            if (viewMode === 'single') {
                navigate(`/exam/${id}/question/0`);
            } else {
                // For list mode, navigate to the exam overview or first question
                navigate(`/exam/${id}`);
            }
        }
    };

    const handleSubmit = async () => {
        if (isSubmitting || submitted) return;

        setIsSubmitting(true);
        isSubmittingRef.current = true;

        try {
            // Prepare submission data
            const submissionData = {
                exam_id: id,
                answers: Object.entries(answers).map(([questionId, userAnswer]) => ({
                    question_id: questionId,
                    user_answer: userAnswer,
                    violated_rules: violations.filter(v => v.question_id === questionId).map(v => v.type),
                    points: calculatePoints(questionId, userAnswer),
                })),
                total_points: calculateTotalPoints(),
                started_at: startedAt ? new Date(startedAt) : null,
                completed_at: new Date(),
                status: 'submitted',
            };

            // Submit to Supabase
            const { data, error } = await supabase
                .from('submissions')
                .insert([submissionData])
                .select('id')
                .single();

            if (error) throw error;

            // Handle successful submission
            setSubmitted(true);
            localStorage.setItem(`durrah_exam_${id}_submitted`, 'true');
            localStorage.setItem(`durrah_exam_${id}_score`, JSON.stringify({ score: submissionData.total_points }));

            // Navigate to result page or show success message
            toast.success(t('examView.submitSuccess'));
            if (data.id) {
                navigate(`/exam/${id}/result`);
            }
        } catch (error) {
            toast.error(t('examView.submitError'));
            console.error('Error submitting exam:', error);
        } finally {
            setIsSubmitting(false);
            isSubmittingRef.current = false;
        }
    };

    const calculatePoints = (questionId: string, userAnswer: any) => {
        const question = exam?.questions.find(q => q.id === questionId);
        if (!question) return 0;

        // For now, let's assume 1 point per question, adjust logic here if needed
        return question.points || 0;
    };

    const calculateTotalPoints = () => {
        // Total points is simply the sum of all question points
        return exam?.questions.reduce((total, q) => total + (q.points || 0), 0) || 0;
    };

    const handleReattempt = () => {
        setSubmitted(false);
        setAnswers({});
        setViolations([]);
        setFlaggedQuestions(new Set());
        setTimeLeft(exam?.settings.time_limit_minutes ? exam.settings.time_limit_minutes * 60 : null);
        setStartedAt(Date.now());
        localStorage.removeItem(`durrah_exam_${id}_submitted`);
        localStorage.removeItem(`durrah_exam_${id}_score`);
        localStorage.removeItem(`durrah_exam_${id}_state`);

        // Optionally, navigate to the first question directly
        navigate(`/exam/${id}/question/0`);
    };

    const handleViolationAcknowledge = () => {
        setShowViolationModal(false);
    };

    const handleFlagQuestion = (questionId: string) => {
        setFlaggedQuestions(prev => {
            const newFlagged = new Set(prev);
            if (newFlagged.has(questionId)) {
                newFlagged.delete(questionId);
            } else {
                newFlagged.add(questionId);
            }
            return newFlagged;
        });
    };

    const handleViewModeChange = (mode: 'list' | 'single') => {
        setViewMode(mode);
        if (mode === 'single') {
            // In single question mode, navigate to the current question directly
            navigate(`/exam/${id}/question/${currentQuestionIndex}`);
        } else {
            // In list mode, navigate to the exam overview
            navigate(`/exam/${id}`);
        }
    };

    // Effect to handle countdown timer and auto-submit logic
    useEffect(() => {
        if (!started || !exam) return;
        if (timeLeft !== null && timeLeft > 0) {
            const timer = setInterval(() => setTimeLeft((p: number | null) => (p && p > 0 ? p - 1 : 0)), 1000);
            return () => clearInterval(timer);
        } else if (timeLeft === 0 && !submitted && !isSubmitting && !showAutoSubmitWarning) {
            // NEW: Show auto-submit warning instead of immediate submission
            setShowAutoSubmitWarning(true);
        }
    }, [started, timeLeft, exam, submitted, isSubmitting, showAutoSubmitWarning]);

    // NEW: Auto-submit countdown effect
    useEffect(() => {
        if (showAutoSubmitWarning && autoSubmitCountdown > 0) {
            const timer = setTimeout(() => {
                setAutoSubmitCountdown(prev => prev - 1);
            }, 1000);
            return () => clearTimeout(timer);
        } else if (showAutoSubmitWarning && autoSubmitCountdown === 0) {
            setShowAutoSubmitWarning(false);
            setAutoSubmitCountdown(5); // Reset for next time
            handleSubmit();
        }
    }, [showAutoSubmitWarning, autoSubmitCountdown]);

    // Check for unanswered questions before submitting
    const handleBeforeSubmit = () => {
        if (exam) {
            const unanswered = exam.questions.filter(q => !answers[q.id]);
            if (unanswered.length > 0) {
                setUnansweredQuestions(unanswered.map(q => q.order || 0));
                setShowUnansweredModal(true);
                return;
            }
        }
        // If no unanswered questions, proceed with submission
        handleSubmit();
    };

    return (
        <div className={`exam-view ${isZenMode ? 'zen-mode' : ''}`} ref={containerRef}>
            <header>
                <Logo />
                <div className="actions">
                    <LanguageSwitcher />
                    <button onClick={() => window.location.reload()} title={t('common.reload')}>
                        <Loader2 />
                    </button>
                </div>
            </header>

            <main>
                {submitted && score ? (
                    <div className="result-summary">
                        <h2>{t('examView.resultTitle')}</h2>
                        <p>{t('examView.score', { score: score.score, total: score.max_score })}</p>
                        <p>{t('examView.percentage', { percentage: score.percentage })}</p>
                        <button onClick={
