// helper: get user session or attempt background anonymous sign-in (non-blocking)
import { useEffect, useState, useRef } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import toast from 'react-hot-toast';
import { AlertTriangle, CheckCircle, Loader2, Save, Flag, LayoutGrid, Sun, Moon, Calculator as CalcIcon, Star, Eye, AlertCircle, X } from 'lucide-react';
import { supabase } from '../lib/supabase';
import { ViolationModal } from '../components/ViolationModal';
import { Logo } from '../components/Logo';
import { useTranslation } from 'react-i18next';
import { LanguageSwitcher } from '../components/LanguageSwitcher';
import { Calculator } from '../components/Calculator';

interface Question {
    id: string;
    type: string;
    question_text: string;
    options?: string[];
    points: number;
    correct_answer?: string | string[] | null;
    media_url?: string | null;
    media_type?: 'image' | 'audio' | 'video' | null;
}

interface Violation {
    type: string;
    timestamp: string;
}

interface Exam {
    id: string;
    title: string;
    description: string;
    questions: Question[];
    required_fields?: string[];
    settings: {
        require_fullscreen: boolean;
        detect_tab_switch: boolean;
        disable_copy_paste: boolean;
        disable_right_click: boolean;
        max_violations: number;
        time_limit_minutes: number | null;
        randomize_questions?: boolean;
        show_results_immediately?: boolean;
        show_detailed_results?: boolean; // NEW
        // optional scheduling fields (back-end and editor may use either naming)
        start_time?: string | null;
        end_time?: string | null;
        start_date?: string | null;
        end_date?: string | null;
        // email whitelist
        restrict_by_email?: boolean;
        allowed_emails?: string[];
    };
}

export default function ExamView() {
    const { t } = useTranslation();
    const { id } = useParams();
    const navigate = useNavigate();
    const [searchParams] = useSearchParams();
    const submissionId = searchParams.get('submission');
    const isReviewMode = !!submissionId;
    const [exam, setExam] = useState<Exam | null>(null);
    const [studentData, setStudentData] = useState<Record<string, string>>({});
    const [started, setStarted] = useState(false);
    const [answers, setAnswers] = useState<Record<string, any>>({});
    const [violations, setViolations] = useState<Violation[]>([]);
    const [timeLeft, setTimeLeft] = useState<number | null>(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [submitted, setSubmitted] = useState(false);
    const [score, setScore] = useState<{ score: number; max_score: number; percentage: number; submission_id?: string } | null>(null);

    const [showViolationModal, setShowViolationModal] = useState(false);
    const [violationMessage, setViolationMessage] = useState({ title: '', message: '' });
    const [hasPreviousSession, setHasPreviousSession] = useState(false);
    const [isAvailable, setIsAvailable] = useState(true);
    const [availabilityMessage, setAvailabilityMessage] = useState<string | null>(null);
    const [flaggedQuestions, setFlaggedQuestions] = useState<Set<string>>(new Set());

    const [showQuestionGrid, setShowQuestionGrid] = useState(false);
    const [fontSize, setFontSize] = useState<'normal' | 'large' | 'xlarge'>('normal');
    const [highContrast, setHighContrast] = useState(false);
    const [showCalculator, setShowCalculator] = useState(false);
    const [startedAt, setStartedAt] = useState<number | null>(null);

    // New State for View Modes
    const [viewMode, setViewMode] = useState<'list' | 'single'>('single'); // Default to single question per page
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [isZenMode, setIsZenMode] = useState(false);

    // Review Mode State
    const [reviewData, setReviewData] = useState<{
        submission: any;
        submissionAnswers: any[];
    } | null>(null);


    const containerRef = useRef<HTMLDivElement>(null);
    const isSubmittingRef = useRef(false);

    // Load exam data or review data
    useEffect(() => {
        if (id) {
            fetchExam();
            if (isReviewMode && submissionId) {
                fetchReviewData(submissionId);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [id, isReviewMode, submissionId]);

    // Check for existing session and submitted status on mount
    useEffect(() => {
        if (!id) return;

        // Check if already submitted on this device
        const submittedFlag = localStorage.getItem(`durrah_exam_${id}_submitted`);
        if (submittedFlag) {
            setSubmitted(true);
            // Optionally try to load the score if we saved it
            const savedScore = localStorage.getItem(`durrah_exam_${id}_score`);
            if (savedScore) {
                const parsed = JSON.parse(savedScore);
                setScore(parsed);

            }
            return;
        }

        // Check for active session to restore
        const savedState = localStorage.getItem(`durrah_exam_${id}_state`);
        if (savedState) {
            try {
                const parsed = JSON.parse(savedState);
                setStudentData(parsed.studentData || {});
                setAnswers(parsed.answers || {});
                setViolations(parsed.violations || []);
                if (parsed.flaggedQuestions) {
                    setFlaggedQuestions(new Set(parsed.flaggedQuestions));
                }
                setStarted(parsed.started || false);
                if (parsed.timeLeft !== null && parsed.timeLeft !== undefined) {
                    setTimeLeft(parsed.timeLeft);
                }
                setHasPreviousSession(true);
                setHasPreviousSession(true);
                toast.success(t('examView.previousSession'));
            } catch (e) {
                console.error('Failed to restore session', e);
            }
        }
    }, [id]);

    // Save state to localStorage whenever it changes
    useEffect(() => {
        if (!id || submitted) return;

        // Only save if we have started or have entered some data
        if (started || Object.keys(studentData).length > 0) {
            const stateToSave = {
                studentData,
                answers,
                violations,
                flaggedQuestions: Array.from(flaggedQuestions),
                timeLeft,
                started,
                startedAt,
                lastUpdated: Date.now()
            };
            localStorage.setItem(`durrah_exam_${id}_state`, JSON.stringify(stateToSave));
        }
    }, [id, studentData, answers, violations, timeLeft, started, startedAt, submitted, flaggedQuestions]);

    const fetchExam = async () => {
        try {
            // Securely fetch exam data (exclude correct_answer for security)
            const { data: examData, error } = await supabase.from('exams').select('*').eq('id', id).single();
            if (error) throw error;

            // Fetch questions WITHOUT correct_answer column
            const { data: qData, error: qError } = await supabase
                .from('questions')
                .select('id, type, question_text, options, points, randomize_options, exam_id, created_at, media_url, media_type')
                .eq('exam_id', id);

            if (qError) throw qError;

            const settings = examData.settings || {};
            const normalizedSettings: any = { ...settings };
            // support both naming conventions
            if (!normalizedSettings.start_time && settings.start_date) normalizedSettings.start_time = settings.start_date;
            if (!normalizedSettings.end_time && settings.end_date) normalizedSettings.end_time = settings.end_date;

            setExam({ ...examData, questions: qData || [], settings: normalizedSettings });

            // Apply Randomization if enabled
            let processedQuestions = [...(qData || [])];

            // 1. Randomize Questions Order
            if (normalizedSettings.randomize_questions) {
                for (let i = processedQuestions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [processedQuestions[i], processedQuestions[j]
